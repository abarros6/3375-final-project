/*designing the elevator control system as an FSMSTATES: q0 = idle-state, q1-q7 = next-floor-state, q* = passcode-entered-state, qE = emergency-stateINPUTS: switches 3-9 map to floors 1-7. Buttons 0-3 are mapped to passcode input.		potentiometer attached to adc is mapped to the elevator weight sensor.TRANSITIONS: q0 (switches 3-9)-> q1-7 // q0 (buttons 0-3)-> q* // q0 (switch 2)-> qE			 q1-7 (e)-> q0 // q1-7 (switch 2)-> qE			 q* (switches 3-9)-> q1-7 // q* (switch 2)-> qE 			 qE (switch 2)-> q0 *///all the memory locations needed #define LED_BASE 0xFF200000;#define ADC_BASE 0xFF204000;#define KEY_BASE 0xFF200050;#define SW_BASE 0xFF200040;#define HEX3_HEX0_BASE 0xFF20020;#define GPIO_BASE 0xFF200060;//first need to create pointers to all of the parts of the board in use //first need to create pointers to all of the parts of the board in use volatile int *led_ptr = (int *)LED_BASE; //pointer for the LEDs volatile int *sw_ptr = (int *)SW_BASE; //pointer for the switches volatile int *btn_ptr = (int *)KEY_BASE; //pointer for the buttons volatile int *adc_ptr = (int *)ADC_BASE; //pointer for the ADCvolatile int *hex_ptr = (int *)HEX3_HEX0_BASE; //pointer for the hex display volatile int *gpio_ptr = (int *)GPIO_BASE; //pointer for the gpio pins volatile int *audio_ptr = (int *)AUDIO_BASE;//gloabal valuesvolatile int flag;volatile int floor;//this is lab three in the main function, need adapt it - adapted to show floors and save locally//for the contextual logic on an elevator //one of the potentiometers for weight sensor and one for the position of the elevator int ReadSwitches(void) //read slide switch bank and return current value{	int switchValue;    switchValue = *(sw_ptr) & 0b1111;    return (switchValue);}void SoundAlarm() {	    /*used for audio record/playback*/    int fifospace;    int buffer_index = 0;    int left_buffer[BUF_SIZE];    int right_buffer[BUF_SIZE]; /*read and echo audio data*/		*(led_ptr) = 0b1000000000;                         // turn on LEDR_9    fifospace = *(audio_ptr + 1);                 // read the audio port fifospace register    if ((fifospace & 0x00FF0000) > BUF_THRESHOLD) // check WSRC    {        // output data until the buffer is empty or the audio-out FIFO is full        while ((fifospace & 0x00FF0000) && (buffer_index < BUF_SIZE))        {            *(audio_ptr + 2) = left_buffer[buffer_index];            *(audio_ptr + 3) = right_buffer[buffer_index];            ++buffer_index;            fifospace = *(audio_ptr + 1); // read the audio port fifospace register        }    }}void DisplayResults(){ 	int rMask = 0b1000000000000000;	int max = 4096; // 2^12 -> bits 0-11 are the 12 data bits of the adc channels		// therefore the max data that the potwntiometer can output is 12 bits worth of information	if ((flag == 0) && (((*(adc_ptr)) && (rMask) >> 15) == 1)) //floor sensing	{		if ((*(adc_ptr) == 0))		{			*(gpio_ptr) = 0b1000000000; //floor 1			floor = 1;		}		else if ((*(adc_ptr) > 0) && (*(adc_ptr) < (max * 1 / 10)))		{			*(gpio_ptr) = 0b1100000000; //floor 2			floor = 2;		}		else if ((*(adc_ptr) >= (max * 1 / 10)) && (*(adc_ptr) < (max * 2 / 10)))		{			*(gpio_ptr) = 0b1110000000; //floor 3			floor = 3;		}		else if ((*(adc_ptr) >= (max * 2 / 10)) && (*(adc_ptr) < (max * 3 / 10)))		{			*(gpio_ptr) = 0b1111000000; //floor 4			floor = 4;		}		else if ((*(adc_ptr) >= (max * 3 / 10)) && (*(adc_ptr) < (max * 4 / 10)))		{			*(gpio_ptr) = 0b1111100000; //floor 5			floor = 5;		}		else if ((*(adc_ptr) >= (max * 4 / 10)) && (*(adc_ptr) < (max * 5 / 10)))		{			*(gpio_ptr) = 0b1111110000; //floor 6			floor = 6;		}		else if ((*(adc_ptr) >= (max * 5 / 10)) && (*(adc_ptr) < (max * 6 / 10)))		{			*(gpio_ptr) = 0b1111111000; //floor 7			floor  = 7;		}					}	else if ((flag == 1) && (((*(adc_ptr + 1)) && (rMask) >> 15) == 1)) //weight sensing	{			if ((*(adc_ptr + 1) == 0))		{			*(gpio_ptr) = 0b0000000000;		}		else if ((*(adc_ptr + 1) > 0) && (*(adc_ptr + 1) < (max * 1 / 10)))		{			*(gpio_ptr) = 0b1000000000;		}		else if ((*(adc_ptr + 1) >= (max * 1 / 10)) && (*(adc_ptr + 1) < (max * 2 / 10)))		{			*(gpio_ptr) = 0b1100000000;		}		else if ((*(adc_ptr + 1) >= (max * 2 / 10)) && (*(adc_ptr + 1) < (max * 3 / 10)))		{			*(gpio_ptr) = 0b1110000000;		}		else if ((*(adc_ptr + 1) >= (max * 3 / 10)) && (*(adc_ptr + 1) < (max * 4 / 10)))		{			*(gpio_ptr) = 0b1111000000;		}		else if ((*(adc_ptr + 1) >= (max * 4 / 10)) && (*(adc_ptr + 1) < (max * 5 / 10)))		{			*(gpio_ptr) = 0b1111100000;		}		else if ((*(adc_ptr + 1) >= (max * 5 / 10)) && (*(adc_ptr + 1) < (max * 6 / 10)))		{			*(gpio_ptr) = 0b1111110000;		}		else if ((*(adc_ptr + 1) >= (max * 6 / 10)) && (*(adc_ptr + 1) < (max * 7 / 10)))		{			*(gpio_ptr) = 0b1111111000;		}		else if ((*(adc_ptr + 1) >= (max * 7 / 10)) && (*(adc_ptr + 1) < (max * 8 / 10)))		{			*(gpio_ptr) = 0b1111111100;		}		else if ((*(adc_ptr + 1) >= (max * 8 / 10)) && (*(adc_ptr + 1) < (max * 9 / 10)))		{			*(gpio_ptr) = 0b1111111110;		}		else if ((*(adc_ptr + 1) >= (max * 9 / 10)) && (*(adc_ptr + 1) < (max))) // max weight limit imposed 		{			*(gpio_ptr) = 0b1111111111;			SoundAlarm();		}	}}int main(void){	*(adc_ptr) = 0b1;	*(adc_ptr + 1) = 0b1;	*(gpio_ptr + 1) = 0b1111111111;	while (1)	{				int switchValue = *(sw_ptr);	 		if (switchValue == 0x0) //carriage position in terms of floor		{			flag = 0;			*(led_ptr) = 0b1;		}		else if (switchValue == 0b0100000000) //weight sensing attribute		{			flag = 1;			*(led_ptr) = 0b10;		}		else if (switchValue == 0b0010000000) //alarm switch		{			SoundAlarm();			*(led_ptr) = 0b100;		}		DisplayResults();					}}/* // Reads switchesint ReadSwitches(void){    return (*(sw_ptr));}// Reads buttonsint ReadButton(int btn){    // Returns 1 if the given button is pressed, 0 otherwise due to & operator    return ((*btn_ptr >> (btn)) & 1);}//if the correct buttons are pressed then return 1 otherwise return 0int HandlePassword(void){	//this if statement controls the password values	//in this case buttons 0,2,3 need to be pressed 	if(ReadButton(0) && ReadButton(2) && ReadButton(3))	{		return 1;	}		return 0;}int main (void) {	//first need to init the constraints on the elevator 	//ie the total weight capacity of the elevator 	//also the total number of floors and how they correspond to the leds	//the correct passcode input etc...		while(1)	{		//this is where the code for disabled users goes		if (HandlePassword()&1)		{			*(led_ptr) = *(sw_ptr);		}				//this is where the code for normal users goes 		if (HandlePassword()&1)		{			*(led_ptr) = 0b1;		}	}		}*/